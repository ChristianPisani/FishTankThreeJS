/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 .\\CornPlant.glb
*/

import React, {
    useEffect,
    useRef,
    useState
} from 'react'
import {
    Object3D,
    Vector3
} from "three";
import {
    GoldFish
} from "../GoldFish.jsx";
import {
    useFrame
} from "@react-three/fiber";
import {
    Boid,
    Flock
} from "./Flock.js";


export function FishGroup(props) {
    const fishRef = useRef();
    const fishRef1 = useRef();
    const fishRef2 = useRef();
    const fishRef3 = useRef();
    const fishRef4 = useRef();
    const tempObject = new Object3D();

    const flock = useRef(new Flock());

    const fg = [];

    const distance = 10;

    for (let i = 0; i < 400; i++) {
        const randomScale = Math.random() * 0.5 + 0.1;

        fg.push({
                position: new Vector3(
                    Math.random() * distance - distance / 2,
                    Math.random() * distance + 20,
                    Math.random() * distance - distance / 2
                ),
                rotation: new Vector3(
                    Math.random() * 0.5,
                    Math.random() * 360,
                    Math.random() * 0.5
                ),
                scale: new Vector3(randomScale, randomScale, randomScale)
            }
        );
    }

    flock.current.boids = fg.map(fish => {
        const boid = new Boid();
        boid.position = fish.position;
        boid.scale = fish.scale;
        boid.rotation = fish.rotation;

        return boid;
    });

    const updateFishPositions = () => {
        if (fishRef?.current == null) return;

        let i = 0;
        flock?.current?.boids?.forEach(fish => {
            const id = i++;
            const {
                position,
                rotation,
                scale,
                velocity
            } = fish;

            tempObject.position.set(position.x, position.y, position.z);
            tempObject.scale.set(scale.x, scale.y, scale.z);
            tempObject.lookAt(position.x - velocity.x, position.y - velocity.y / 2, position.z - velocity.z);
            

            tempObject.updateMatrix();

            fishRef.current.setMatrixAt(id, tempObject.matrix);
            fishRef.current.instanceMatrix.needsUpdate = true;
            fishRef1.current.setMatrixAt(id, tempObject.matrix);
            fishRef1.current.instanceMatrix.needsUpdate = true;
            fishRef2.current.setMatrixAt(id, tempObject.matrix);
            fishRef2.current.instanceMatrix.needsUpdate = true;
            fishRef3.current.setMatrixAt(id, tempObject.matrix);
            fishRef3.current.instanceMatrix.needsUpdate = true;
            fishRef4.current.setMatrixAt(id, tempObject.matrix);
            fishRef4.current.instanceMatrix.needsUpdate = true;
        });
    }

    useFrame(() => {
        flock?.current?.update();
        updateFishPositions();
    })

    return (
        <>
            <group {...props} >
                <GoldFish
                    fishRef={[fishRef, fishRef1, fishRef2, fishRef3, fishRef4]}
                    amount={flock.current.boids.length}></GoldFish>
            </group>
        </>);
}